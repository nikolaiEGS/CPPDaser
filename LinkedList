#include<iostream>
using namespace std;

template <typename T> class List {
	class Node {
	public:
		T value;
		Node* next;
		Node* prev;
		Node(T val) : value(val), next(nullptr), prev(nullptr) {}
	};

	Node* head = nullptr;
	Node* tail = nullptr;
	int size = 0;
public:

	List() = default;
	/* ------------------ does not work -----------------------------------
	List(const List& x) {
		cout << "insight List(x)" << endl;
		Node* i = nullptr;
		for (i = x.head; x.head != nullptr; i = x.head->next) {
			this->push(i->value);
		}
	}
	*/
	// --------------- works -------------------------------------------------------
	void push(T value) {
		cout << "insight push" << endl;
		Node* temp = new Node(value);
		if (head == nullptr) {
			head = temp;
			tail = temp;
		}
		else {
			tail->next = temp;
			temp->prev = tail;
			tail = temp;
		}
		size++;
	}

	T pop() {
		if (head != NULL) {
			if (head->next == NULL) {
				Node* temp = head;
				head = nullptr;
				tail = nullptr;
				T v = temp->value;
				delete temp;
				return v;
			}
			else {
				Node* temp = tail;
				tail = tail->prev;
				tail->next = nullptr;
				T v = temp->value;
				delete temp;
				return v;
			}
		}
		size--;
	}
	// --------------------------- works ---------------------------------------
	void deleteElement(T val) {
		Node* i = nullptr;
		for (i = head; i != nullptr; i = i->next) {
			if (i->value == val) {
				// case if only one element in the List
				if (i->prev == NULL && i->next == NULL) {
					Node* temp = i;
					head = nullptr;
					tail = nullptr;
					delete temp;
					break;
				}
				// case if i is tail -------------------
				else if (i->next == NULL) {
					Node* temp = i;
					tail = tail->prev;
					tail->next = nullptr;
					delete temp;
					break;
				}
				// case if i is head --------------------------
				else if (i->prev == NULL) {
					Node* temp = i;
					head = head->next;
					head->prev = nullptr;
					delete temp;
					break;
				}
				// cas if element bitween Tail and Head --------
				else {
					Node* temp = i;
					i->prev->next = i->next;
					i->next->prev = i->prev;
					delete temp;
					break;
				}
			}
		}
		size--;
	}
	
	// ---------- works ----------------------------------------------
	bool findElement(T val) {
		Node* i = nullptr;
		for (i = head; i != nullptr; i = i->next) {
			if (i->value == val) {
				return true;
			}
			else{ return false; }
				
		}
	}
	// ------------ works ---------------------------------------------
	int sizef() { return size; }


	void printElements(){
		Node* i = nullptr;
		for (i = head; i != nullptr; i = i->next) {
			cout << "--------- insight print ---------" << endl;
			cout << i->value << endl;
		}
	}
};

int main() {
	List <int> x;
	//List <int> y(x);
	x.push(4);
	x.push(8);
	x.push(9);
	x.printElements();

	//---- test pop function
	//int help = x.pop();
	//cout << "pop == "<< help << endl;

	cout << " --- test deleteElement function ------" << endl;
	x.deleteElement(9);
	x.printElements();

	cout << " --- test findElement function ------" << endl;
	bool test = x.findElement(40);
	if (test)
		cout << "element found" << endl;
	else
		cout << "element not found" << endl;

	cout << " --- test fsize function ------" << endl;
	int s = x.sizef();
	cout << "size == " << s << endl;

	//cout << "--------- test ---------" << endl;
	//y.printElements();
}
