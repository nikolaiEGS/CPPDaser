#include<iostream>
#include<vector>


//separate hpp and cpp

template <typename T> class List {
	struct Node {
		T value;
		Node* next;
		Node* prev;
		Node(const T& val) : value{ val }, next{ nullptr }, prev{ nullptr } {}
		class List;
	};
	Node* head = nullptr;
	Node* tail = nullptr;
	std::size_t size = 0;

	void releaseList() {
		Node* currendNode = head;
		while (currendNode) {
			Node* tempNode = currendNode->next;
			delete currendNode;
			//cout << "DELETE " << endl;
			currendNode = tempNode;
		}
		head = nullptr;
		tail = nullptr;
		size = 0;
		
	}
public:
	static std::size_t countList;

	static void swapList(List& first, List& second);
	static List& copyList(List& destination, const List& right);
	static List& moveList(List& destination, List& right);

	List() = default;
	//----- copy constructor -- works ----------------------------------------------------------------------
	List(const List& newElem) {
		copyList(*this, newElem);
	}
	// ------------------- works --------------------------
	List(std::initializer_list<T> val) {
		for (const auto& valTemp : val)
			push(valTemp);
		countList++;
	}

	//------ move constructor -----------------------------------------
	
	List(List&& moveElem) noexcept : List() {
		std::cout << "-- moveConst --" << std::endl;
		swapList(*this, moveElem);
	}

	~List() {
		releaseList();
	}
	
	
	// --------------- works -------------------------------------------------------
	void push(const T& value) {
		Node* temp = new Node(value);
		if (head == nullptr) {
			head = temp;
			tail = temp;
		}
		else {
			tail->next = temp;
			temp->prev = tail;
			tail = temp;
		}
		size++;
	}

	// ------------------- works ---------------------------------------------
	void pop() {
		deleteElement_byIndex(size - 1, true);
	}
	// ---------- works -------------------------------------------------------
	void deleteElement_byIndex(const int index, bool reverseIterator) {
		if (head != nullptr && index < size && index >= 0) {
			Node* element = findElement_byIndex(index, reverseIterator);
			if (element->prev != nullptr) {
				element->prev->next = element->next;
			}
			else {
				head = element->next;
			}
			if (element->next != nullptr) {
				element->next->prev = element->prev;
			}
			else {
				tail = element->prev;
			};
			delete element;
			--size;
		}
	}
//----------------------------------- works ----------------------------------------------------
	void deleteElement_byIndex(std::vector<int> values) {
		if (values.empty() != true) {
			for (int vecIndex = 0; vecIndex < values.size(); vecIndex++) {
				if (values.size() == 1) {
					deleteElement_byIndex(values[vecIndex], false);
				}
				else {
					if (values[vecIndex] >= size / 2) {
						deleteElement_byIndex(values[vecIndex], true);
					}
					else {
						deleteElement_byIndex(values[vecIndex], false);
					}
					if (vecIndex != values.size() - 1) {
						if (values[vecIndex] < values[vecIndex + 1]) {
							for (int vecIndex_ = vecIndex + 1; vecIndex_ < values.size(); vecIndex_++) {
								values[vecIndex_] = values[vecIndex_] - 1;
							}
						}
					}
				}
			}
		}
	}
	// -------------------------- wokrs ---------------------------------------
	void deleteElement_byValue(const int& val, bool allElem) {
		int countIndex = 0;
		Node* currentElem = head;

		while (currentElem != nullptr) {
			if (currentElem->value == val) {
				currentElem = currentElem->next;
				deleteElement_byIndex(countIndex, false);
				if (allElem == false) { break; }
			}
			else {
				currentElem = currentElem->next;
				countIndex++;
			}
		}
	}
	//------------------- need to be checked -----------------------------------------
	Node* findElement_byIndex(const int index, bool reverseIterator) {
		if (index < size && index >= 0) {
			if (reverseIterator == false) {
				int countIndex = 0;
				for (Node* currentElem = head; currentElem != nullptr; currentElem = currentElem->next) {
					if (countIndex++ == index) {
						return currentElem;
					}
				}
			}
			else {
				int countIndex = size - 1;
				for (Node* currentElem = tail; currentElem != nullptr; currentElem = currentElem->prev) {
					if (countIndex-- == index) {
						return currentElem;
					}
				}
			}
		}
		else { return nullptr; }
	}
	// ------------------- works -------------------------------------------
	std::vector<int> findElement_byValue(const T& val) const {
		std::vector<int> indecies{};
		int countIndex = 0;
		for (const Node* currentElem = head;
			currentElem != nullptr; currentElem = currentElem->next, countIndex++) {
			if (currentElem->value == val) {
				indecies.push_back(countIndex);
			}
		}
		return indecies;
	}
	// ------------ works ---------------------------------------------
	std::size_t sizef() const { return size; }
	// ---------------------- works ------------------------------
	void reverse() {
		List<T> tempList(*this);
		releaseList();
		for (const Node* currentElem = tempList.tail; currentElem != nullptr; currentElem = currentElem->prev) {
			push(currentElem->value);
		}
		tempList.releaseList();
	}

		// ------------ works ---------------------------------------------
	List& operator+=(const List& x) {
		for (const Node* currentElem = x.head; currentElem != nullptr; currentElem = currentElem->next) {
			push(currentElem->value);
		}
		size++;
		return *this;
	}

	//---------------------------------- works ------------------------------------------------
	bool operator==(const List& right) const {
		if (size == right.sizef()) {
			Node* rightTemp = right.head;

			for (auto left = head; left != nullptr; left = left->next, rightTemp = rightTemp->next) {
					if (left->value != rightTemp->value) { return false; }
			}
			return true;
		}
		else { return false; }
	}

	// ---------------------------------------------
	List& operator=(List right) {
		std::cout << "--- copy assignment ---" << std::endl;
		swapList(*this, right);
		return *this;
	}

	// move assignment ------ --------------------------------
	List& operator=(List&& right) noexcept {
		std::cout << "--- move assignment ---" << std::endl;
		releaseList();
		swapList(*this, right);
		return *this;
	}
	/*
	// --------- implementation is wrong, i dont know how to fix it -------------------------
	List& operator+(const List<T>& right) {
		List<T> tempList;
		for (const Node* currentElem = head; currentElem != nullptr; currentElem = currentElem->next) {
			tempList.push(currentElem->value);
		}
		for (const Node* currentElem = right.head; currentElem != nullptr; currentElem = currentElem->next) {
			tempList.push(currentElem->value);
		}
		return tempList;
	}
	//--------------------------------------------------------------------------------------------------
	std::ostream& operator<<(std::ostream& ost, const List<T>& list) {
		for (const Node* currentElem = list.head; currentElem != nullptr; currentElem = currentElem->next) {
			ost << currentElem->value << "  ,  " << std::flush;
		}
		return ost;
	}*/

	void printElements() const {
		if (head != nullptr) {
			for (const Node* currentElem = head; currentElem != nullptr; currentElem = currentElem->next) {
				std::cout << currentElem->value << " , " ;
			}
			std::cout << std::endl;
		}
	}
};

template <typename T>
std::size_t List<T>::countList = 0;

/*
template <typename T>
void List<T>::swapList(List<T>& first, List<T>& second) {
	std::cout << "-- swapFunction --" << std::endl;
	List<T> temp(std::move(first));
	first = std::move(second);
	second = std::move(temp);
}
*/
template <typename T>
void List<T>::swapList(List<T>& first, List<T>& second) {
	std::cout << "-- swapFunction --" << std::endl;
	List<T> temp;
	moveList(temp, first);
	moveList(first, second);
	moveList(second, temp);
}
template <typename T>
List<T>& List<T>::copyList(List<T>& destination, const List<T>& right) {
	destination.releaseList();
	for (const Node* currentElem = right.head; currentElem != nullptr; currentElem = currentElem->next) {
		destination.push(currentElem->value);
	}
	return destination;
}

template <typename T>
List<T>& List<T>::moveList(List<T>& destination, List<T>& right) {
	copyList(destination, right);
	right.releaseList();
	return destination;
}

/*
template <typename T>
List<T>& operator+(List<T> left, List<T> right) {
	List::Node* temp = new List::Node();
	for (const Node* currentElem = left.head; currentElem != nullptr; currentElem = currentElem->next) {
		temp->push(currentElem->value);
	}
	for (const Node* currentElem = right.head; currentElem != nullptr; currentElem = currentElem->next) {
		temp->push(currentElem->value);
	}
	return *temp;
}*/

int main() {
	List <int> x;
	//List <int> y(x);
	List <int> k;
	k.push(4);
	k.push(8);
	k.push(9);
	k.push(2);
	std::cout << std::endl;
	// test: pop function --------  >> works --------------------------------
	std::cout <<"popfunction"<< std::endl;
	k.pop();
	k.printElements();
	std::cout << std::endl;
	x.push(4);
	x.push(8);
	x.push(8);
	x.push(3);
	x.push(9);
	x.printElements();

	std::cout << std::endl;

	List<int> test({ 1,2,3,4,5,6,9,9,9 });
	test.printElements();
	test.pop();
	test.printElements();

	std::cout << std::endl;

	//test.deleteElement_byValue(5);
	//test.deleteElement_byValue(9);
	//test.printElements();

	std::cout << std::endl;

	std::cout << "test reversefunction -----------"<< std::endl;
	test.reverse();
	test.printElements();

	std::cout << std::endl;

	List<int> tt({ 1,2,9,4,1,9,9,7,8 });
	tt.printElements();
	tt.deleteElement_byValue(9, true);
	std::cout << std::endl;
	tt.printElements();
	std::cout << std::endl;
	std::cout <<"countList == "<< List<int>::countList<< std::endl;
	std::cout << std::endl;
	// test deletElement_byIndex(vector) ---------  works -------
	std::cout << "test deleteElement by indecies VECTOR -----------" << std::endl;
	List<int> hh({ 10, 20, 30, 40, 50, 60, 70, 80, 90, 100 });
	hh.printElements();
	std::vector<int> indicies({ 9,0 });
	hh.deleteElement_byIndex(indicies);
	std::cout << std::endl;
	hh.printElements();

	// test swap -------
	List<int> sw({ 2,2,2,2,2 });
	List<int> swsw({ 9,9,9,9,9 });
	sw.printElements();
	swsw.printElements();

	std::cout << std::endl;
	List<int>::swapList(sw, swsw);
	sw.printElements();
	swsw.printElements();

	std::cout << std::endl;
	sw = swsw;
	sw.printElements();



	//std::cout << "test << Operator -----------" << std::endl;
	//std::cout << test << std:endl;
	//std::cout << "+ operator -----------" << std::endl;
	//List<int> zz;
	//zz = test + k;
	//zz.printElements();
	//cout << " x size " << x.sizef() << endl; // same size after pop
	// test: delate by index >> works ---------------------------------
	//x.printElements();
	//cout << " --- test delete_byIndex function ------" << endl;
	//x.deleteElement_byIndex(0);
	//x.printElements();


// test: deleteElement_byValue funciton  ----- ---------------------------------------------------------------------------------------------------

	//cout << " --- test deleteElement_byValue function ------" << endl;
	//x.deleteElement_byValue(8);
	//x.printElements();
/*
	// test: findElement_byValue()  ------------------ works ---------------------------------------------
	cout << " --- test findElement function ------" << endl;
	vector<int> test = x.findElement_byValue(8);
	for (int i = 0; i < test.size(); i++) {
		cout << test[i] << endl;
	}
	if (test.size() == 0) { cout << "Element not found" << endl; }
	*//**
	//--------------------------------------------------------------------
	cout << " --- test fsize function ------" << endl;
	int s = x.sizef();
	cout << "size == " << s << endl;

	//------------------- works ------------------------------------------------
	cout << " --- test += operator ------" << endl;
	List<int> xx;
	xx.push(1);
	xx.push(1);
	xx.push(1);
	xx.push(1);
	x += k;
	x.printElements();


	//------------------ approved --------------------------------------------------
	cout << " --- test == operator ------" << endl;
	List <int> u;
	u.push(1);
	u.push(4);
	List <int> p;
	p.push(1);
	p.push(4);
	cout << "PPPPPPPPP\n";
	p.printElements();
	if (u == p) { cout << "equal" << endl; }
	else { cout << "not equal" << endl; }
	cout << "PPPPPPPPP\n";
	p.printElements();

	List<int> xxx(xx);
	xxx.printElements();

	//p.reverse();
	//p.printElements();
	cout << "----------- Test = operator ---------------------" << endl;
	k.printElements();
	cout << endl;
	x.printElements();
	cout << endl;
	x = k;
	x.printElements();
	cout << endl;
	k.printElements();

	// test: copy constructor -----------------------------------------
	cout << "--------- test move constructor ---------" << endl;
	List<int> l();
	p = l();
	p.printElements();
	// test: = operator  -----------------------------------------
	cout << "--------- test operator =  ---------" << endl;
	x.printElements();
	x = k;
	cout << "print after = " << endl;
	x.printElements();
	*/
}