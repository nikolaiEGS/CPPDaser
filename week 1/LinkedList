#include<iostream>
using namespace std;

template <typename T> class List {
	class Node {
	public:
		T value;
		Node* next;
		Node* prev;
		Node(T val) : value(val), next(nullptr), prev(nullptr) {}
	};

	Node* head = nullptr;
	Node* tail = nullptr;
	int size = 0;

public:

	List() = default;

// ------------------ does not work -----------------------------------
	/*List(const List& x) {
		cout << "insight List(x)" << endl;
		Node* i = nullptr;
		for (i = x.head; x.head != nullptr; i = i->next) {
			this->push(i->value);
		}
		delete i;
	}*/

// --------------- works -------------------------------------------------------
	void push(T value) {
		cout << "insight push" << endl;
		Node* temp = new Node(value);
		if (head == nullptr) {
			head = temp;
			tail = temp;
		}
		else {
			tail->next = temp;
			temp->prev = tail;
			tail = temp;
		}
		size++;
	}

	T pop() {
		if (head != NULL) {
			if (head->next == NULL) {
				Node* temp = head;
				head = nullptr;
				tail = nullptr;
				T v = temp->value;
				delete temp;
				return v;
			}
			else {
				Node* temp = tail;
				tail = tail->prev;
				tail->next = nullptr;
				T v = temp->value;
				delete temp;
				return v;
			}
		}
		size--;
	}

// --------------------------- works ---------------------------------------
	void deleteElement(T val) {
		Node* i = nullptr;
		for (i = head; i != nullptr; i = i->next) {
			if (i->value == val) {
				// case if only one element in the List
				if (i->prev == NULL && i->next == NULL) {
					Node* temp = i;
					head = nullptr;
					tail = nullptr;
					delete temp;
					break;
				}
				// case if i is tail -------------------
				else if (i->next == NULL) {
					Node* temp = i;
					tail = tail->prev;
					tail->next = nullptr;
					delete temp;
					break;
				}
				// case if i is head --------------------------
				else if (i->prev == NULL) {
					Node* temp = i;
					head = head->next;
					head->prev = nullptr;
					delete temp;
					break;
				}
				// cas if element between Tail and Head --------
				else {
					Node* temp = i;
					i->prev->next = i->next;
					i->next->prev = i->prev;
					delete temp;
					break;
				}
			}
		}
		size--;
	}
	
// ---------- works ----------------------------------------------
	bool findElement(T val) {
		Node* i = nullptr;
		for (i = head; i != nullptr; i = i->next) {
			if (i->value == val) {
				return true;
			}
			else{ return false; }
		}
	}

// ------------ works ---------------------------------------------
	int sizef() { return size; }

// ------------ works (in case of print and if both lists have the same size ---------------------------
	void operator+=(List& x) {
		if (this->size == x.sizef()) {
			Node* i = nullptr;
			Node* k = nullptr;
			for (i = this->head; i != nullptr; i = i->next) {
				for (k = x.head; k != nullptr; k = k->next) {
					cout << "insight += overload ------- 2nd for loop ----------" << endl;
					cout << "i value == " << i->value << "   k value == " << k->value << endl;
					i->value += k->value;
					x.head = x.head->next;
					break;
				}
			}
		}
	}

//---------------------------------- works ------------------------------------------------
	bool operator==(List& x) {
		if (this->size == x.sizef()) {
			cout << "--------- insight == operator ----------" << endl;
			Node* i = nullptr;
			Node* k = nullptr;
			for (i = this->head; i != nullptr; i = i->next) {
				for (k = x.head; k != nullptr; k = k->next) {
					cout << "i value == " << i->value << "   k value == " << k->value << endl;
					if (i->value != k->value) { return false; }
					x.head = x.head->next;
					break;
				}
			}
			delete i, k;
			return true;
		}
		else { return false; }
	}
// ----------------- works ----------------------------------------------------------------------
	List& operator=(List& x){
		cout << "--------- insight operator= --------------" << endl;
		if (*this == x){
			return *this;
		}
		else {
			Node* i = nullptr;
			if (this->head == nullptr) {
				for (i = x.head; i != nullptr; i = i->next) {
					this->push(i->value);
				}
			} else {
				while (this->tail != this->head) {
					this->tail = this->tail->prev;
					delete this->tail->next;
				}
				this->head = x.head;
				for (i = x.head->next; i != nullptr; i = i->next) {
					this->push(i->value);
				}
				return *this;
			}
			delete i;
		}
	}
//--------------------------------------------------------------------------------------------------
	void printElements(){
		Node* i = nullptr;
		for (i = head; i != nullptr; i = i->next) {
			cout << "--------- insight print ---------" << endl;
			cout << i->value << endl;
		}
		delete i;
	}
// ----------------- seems to work, but ther is a warning signal(unhandeld exeption) ----------------------------------------------------------------------
	~List() {
		cout << "---------------- insight destructor ------------" << endl;
		while (tail != head) {
			tail = tail->prev;
			delete tail->next;
		}
		delete tail;
	}
};

int main() {
	List <int> x;
	List <int> k;
	k.push(4);
	k.push(8);
	k.push(9);

	x.push(4);
	x.push(8);
	x.push(8);
	x.push(3);
	x.push(9);

	x.printElements();

// test copy constructor ---------------------------------------------
	//cout << "test copy constructor" << endl;
	//List <int> y(x);
	//y.printElements();

// test pop function -----------------------------------------------------
	//int help = x.pop();
	//cout << "pop == "<< help << endl;

	cout << " --- test deleteElement function ------" << endl;
	x.deleteElement(9);
	x.printElements();

// test findElement() ------------------------------------------------
	cout << " --- test findElement function ------" << endl;
	bool test = x.findElement(40);
	if (test)
		cout << "element found" << endl;
	else
		cout << "element not found" << endl;

// test sizef() --------------------------------------------------------
	cout << " --- test fsize function ------" << endl;
	int s = x.sizef();
	cout << "size == " << s << endl;

//test operator =+ ---------------------------------------------------
	cout << " --- test += operator ------" << endl;
	x += k;
	x.printElements();

// test operator==() -----------------------------------------------------
	cout << " --- test == operator ------" << endl;
	List <int> u;
	u.push(1);
	u.push(2);
	List <int> p;
	p.push(1);
	p.push(2);
	if (u == p) { cout<<"equal"<<endl;}
	else{ cout << "not equal" << endl; }
	
// test consturctor ----------------------------------
	if( u == p){
		List <int> z;
		z.push(99);
	}

// test operator = -----------------------------------
	k = x;
	cout << " ------- test = operator -------------" << endl;
	k.printElements();

}